//-----------------------------------------------------------------------------------
// Code generated by the Toolify Robotics GmbH extension for the SmartMDSD Toolchain 
// 
// Toolify Robotics GmbH
// Weinbergweg 216
// 89075 Ulm 
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//-----------------------------------------------------------------------------------

#include "CommObjectRecognitionObjectPropertiesJSON.hh"

#include "CommBasicObjectsJSON/CommPose3dJSON.hh"
#include "CommBasicObjectsJSON/CommPosition3dJSON.hh"
#include "CommObjectRecognitionObjectsJSON/CommObjectBeliefJSON.hh"
#include "CommObjectRecognitionObjectsJSON/CommTriMeshJSON.hh"
#include "CommObjectRecognitionObjectsJSON/CommObjectRelationJSON.hh"
#include "CommBasicObjectsJSON/CommPose3dJSON.hh"

namespace CommObjectRecognitionObjectsIDL {

void to_json(const CommObjectRecognitionObjectsIDL::CommObjectRecognitionObjectProperties& obj, nlohmann::json& j)
{
	// is_valid: Boolean
	j["is_valid"] = obj.is_valid;
	// object_id: UInt32
	j["object_id"] = obj.object_id;
	// object_type: String
	j["object_type"] = obj.object_type;
	// pose: CommPose3d
	to_json(obj.pose, j["pose"]);
	// dimension: CommPosition3d
	to_json(obj.dimension, j["dimension"]);
	// beliefs: CommObjectBelief[]
	for(size_t idx=0; idx < obj.beliefs.size(); idx++) {
		nlohmann::json array_element;
		to_json(obj.beliefs.at(idx), array_element);
		j["beliefs"].emplace_back(array_element);
	}
	// mesh: CommTriMesh
	to_json(obj.mesh, j["mesh"]);
	// relations: CommObjectRelation[]
	for(size_t idx=0; idx < obj.relations.size(); idx++) {
		nlohmann::json array_element;
		to_json(obj.relations.at(idx), array_element);
		j["relations"].emplace_back(array_element);
	}
	// fill_level: Double
	j["fill_level"] = obj.fill_level;
	// objectSurfacePoses: CommPose3d[]
	for(size_t idx=0; idx < obj.objectSurfacePoses.size(); idx++) {
		nlohmann::json array_element;
		to_json(obj.objectSurfacePoses.at(idx), array_element);
		j["objectSurfacePoses"].emplace_back(array_element);
	}
}

/**
 * this transformation handles missing values and checks for correct types:
 * - missing primitive type values (including simple arrays) are set to zero values
 * - missing object type values are skipped entirely
 * - types are checked before performing the type-cast operation
 */
void from_json(const nlohmann::json& j, CommObjectRecognitionObjectsIDL::CommObjectRecognitionObjectProperties& obj)
{
	// is_valid: Boolean
	if(j.contains("is_valid") && j["is_valid"].is_boolean()) {
		obj.is_valid = j["is_valid"].get<bool>();
	}
	// object_id: UInt32
	if(j.contains("object_id") && j["object_id"].is_number_unsigned()) {
		obj.object_id = j["object_id"].get<unsigned int>();
	}
	// object_type: String
	if(j.contains("object_type") && j["object_type"].is_string()) {
		obj.object_type = j["object_type"].get<std::string>();
	}
	// pose: CommPose3d
	if(j.contains("pose") && j["pose"].is_object()) {
		//from_json(j["pose"], obj.pose);
		obj.pose = j["pose"].get<CommBasicObjectsIDL::CommPose3d>();
	}
	// dimension: CommPosition3d
	if(j.contains("dimension") && j["dimension"].is_object()) {
		//from_json(j["dimension"], obj.dimension);
		obj.dimension = j["dimension"].get<CommBasicObjectsIDL::CommPosition3d>();
	}
	// beliefs: CommObjectBelief[]
	if(j.contains("beliefs") && j["beliefs"].is_array()) {
		auto jbeliefs = j["beliefs"];
		obj.beliefs.resize(jbeliefs.size());
		for(size_t idx=0; idx < jbeliefs.size(); idx++) {
			// convert the json array values individually
			if(jbeliefs.at(idx).is_object()) {
				// from_json(jbeliefs.at(idx), obj.beliefs.at(idx));
				obj.beliefs[idx] = jbeliefs[idx].get<CommObjectRecognitionObjectsIDL::CommObjectBelief>();
			}
		}
	}
	// mesh: CommTriMesh
	if(j.contains("mesh") && j["mesh"].is_object()) {
		//from_json(j["mesh"], obj.mesh);
		obj.mesh = j["mesh"].get<CommObjectRecognitionObjectsIDL::CommTriMesh>();
	}
	// relations: CommObjectRelation[]
	if(j.contains("relations") && j["relations"].is_array()) {
		auto jrelations = j["relations"];
		obj.relations.resize(jrelations.size());
		for(size_t idx=0; idx < jrelations.size(); idx++) {
			// convert the json array values individually
			if(jrelations.at(idx).is_object()) {
				// from_json(jrelations.at(idx), obj.relations.at(idx));
				obj.relations[idx] = jrelations[idx].get<CommObjectRecognitionObjectsIDL::CommObjectRelation>();
			}
		}
	}
	// fill_level: Double
	if(j.contains("fill_level") && j["fill_level"].is_number_float()) {
		obj.fill_level = j["fill_level"].get<double>();
	}
	// objectSurfacePoses: CommPose3d[]
	if(j.contains("objectSurfacePoses") && j["objectSurfacePoses"].is_array()) {
		auto jobjectSurfacePoses = j["objectSurfacePoses"];
		obj.objectSurfacePoses.resize(jobjectSurfacePoses.size());
		for(size_t idx=0; idx < jobjectSurfacePoses.size(); idx++) {
			// convert the json array values individually
			if(jobjectSurfacePoses.at(idx).is_object()) {
				// from_json(jobjectSurfacePoses.at(idx), obj.objectSurfacePoses.at(idx));
				obj.objectSurfacePoses[idx] = jobjectSurfacePoses[idx].get<CommBasicObjectsIDL::CommPose3d>();
			}
		}
	}
}

} // end namespace CommObjectRecognitionObjectsIDL
