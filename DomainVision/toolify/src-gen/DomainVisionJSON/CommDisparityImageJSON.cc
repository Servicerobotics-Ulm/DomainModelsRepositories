//-----------------------------------------------------------------------------------
// Code generated by the Toolify Robotics GmbH extension for the SmartMDSD Toolchain 
// 
// Toolify Robotics GmbH
// Weinbergweg 216
// 89075 Ulm 
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//-----------------------------------------------------------------------------------

#include "CommDisparityImageJSON.hh"

#include "DomainVisionJSON/CommVideoImageJSON.hh"
#include "DomainVisionJSON/CommImageRegionOfInterestJSON.hh"

namespace DomainVisionIDL {

void to_json(const DomainVisionIDL::CommDisparityImage& obj, nlohmann::json& j)
{
	// image: CommVideoImage
	to_json(obj.image, j["image"]);
	// f: Float
	j["f"] = obj.f;
	// t: Float
	j["t"] = obj.t;
	// valid_window: CommImageRegionOfInterest
	to_json(obj.valid_window, j["valid_window"]);
	// min_disparity: Float
	j["min_disparity"] = obj.min_disparity;
	// max_disparity: Float
	j["max_disparity"] = obj.max_disparity;
	// delta_d: Float
	j["delta_d"] = obj.delta_d;
}

/**
 * this transformation handles missing values and checks for correct types:
 * - missing primitive type values (including simple arrays) are set to zero values
 * - missing object type values are skipped entirely
 * - types are checked before performing the type-cast operation
 */
void from_json(const nlohmann::json& j, DomainVisionIDL::CommDisparityImage& obj)
{
	// image: CommVideoImage
	if(j.contains("image") && j["image"].is_object()) {
		//from_json(j["image"], obj.image);
		obj.image = j["image"].get<DomainVisionIDL::CommVideoImage>();
	}
	// f: Float
	if(j.contains("f") && j["f"].is_number_float()) {
		obj.f = j["f"].get<float>();
	}
	// t: Float
	if(j.contains("t") && j["t"].is_number_float()) {
		obj.t = j["t"].get<float>();
	}
	// valid_window: CommImageRegionOfInterest
	if(j.contains("valid_window") && j["valid_window"].is_object()) {
		//from_json(j["valid_window"], obj.valid_window);
		obj.valid_window = j["valid_window"].get<DomainVisionIDL::CommImageRegionOfInterest>();
	}
	// min_disparity: Float
	if(j.contains("min_disparity") && j["min_disparity"].is_number_float()) {
		obj.min_disparity = j["min_disparity"].get<float>();
	}
	// max_disparity: Float
	if(j.contains("max_disparity") && j["max_disparity"].is_number_float()) {
		obj.max_disparity = j["max_disparity"].get<float>();
	}
	// delta_d: Float
	if(j.contains("delta_d") && j["delta_d"].is_number_float()) {
		obj.delta_d = j["delta_d"].get<float>();
	}
}

} // end namespace DomainVisionIDL
